---
title: "Pelagia Analysis"
author: "David Cerny"
date: "10/19/2017"
output: html_document
---

## MCMCTree Concatenated Analysis

Step 1: delete node numbers from the ExaML tree, as the tree file used by MCMCTree should contain no information except for topology and calibrations:

```
gsed -i 's/)[0-9]*:/):/g' ExaML_pelagia-75p-examl.tre
```

Step 2: delete the branch lengths.

```
gsed -i 's/:[^:]*,/,/g' ExaML_pelagia-75p-examl.tre
gsed -i 's/:[^:]*)/)/g' ExaML_pelagia-75p-examl.tre
```

Step 3: make the phylip alignment file compatible with PAML by ensuring that there are at least two spaces between the name of a taxon and the corresponding sequence:

```
gsed -i 's/ /  /g' raxml_95_alignments.phylip
```

Step 4: run a baseml analysis to find appropriate priors to be placed on the `rgene_gamma` and `sigma2_gamma` hyperparameters. The analysis was run under the strict clock model conditioned on the root age, which was set to 113.02 Ma (the mean of the exponential distribution whose offset equals 98 Ma and whose 95th percentile equals 143 Ma):

```{r comment='', echo = FALSE}
cat(readLines("/Users/David/Grive/Alfaro_Lab/Pelagia/pelagia_concatenated_baseml.ctl"), sep = '\n')
```

The baseml analysis finished up in 97:33:54, with the final substitution rate estimate of 0.145074 substitution per 100 million years. Following Alfaro et al., $\alpha$ (the gamma shape parameter) was set to 2 and $\beta$ (the corresponding scale parameter) was chosen so that the mean ($\frac{\alpha}{\beta}$) would equal to the rate when rescaled to a time unit of 10 million years:

```{r}
beta_pelagia <- 2 / (0.145074 / 10)
beta_pelagia
```

This corresponds to the following `rgene_gamma` prior (i.e., the prior on the mean of the lognormal distribution from which branch are drawn):

```{r, echo = FALSE}
curve(dgamma(x, shape = 2, rate = 137.86), from = 0, to = 0.5, main = "Rgene_gamma (mean substitution rate) prior", xlab = "Substitutions per 10 million years", ylab = "Probability density")
```

Following Alfaro et al., the `sigma2_prior`, which specifies the variance of the logarithm of the rate of evolution, was parameterized as the gamma distribution with $\alpha$ = 2 and $\beta$ = 5. This yielded the following rate distribution:

```{r, echo = FALSE}
curve(dlnorm(x, meanlog = log(2/137.86), sdlog = sqrt(2/5)), from = 0, to = 0.5, main = "Relaxed clock rate distribution", xlab = "Substitutions per 10 million years", ylab = "Probability density")
```

Step 5: start 15 MCMCTree analyses under the settings described in the configuration file below:

```{r comment='', echo = FALSE, message = FALSE, warning = FALSE}
cat(readLines("/Users/David/Grive/Alfaro_Lab/Pelagia/pelagia_concatenated_mcmctree.ctl"), sep = '\n')
```

Chain      | Run time
-----------|---------
pelagia 1  | 13:31:44
pelagia 2  | 13:14:21
pelagia 3  | 13:12:01
pelagia 4  | 13:27:41
pelagia 5  | 13:16:03
pelagia 6  | 13:24:40
pelagia 7  | 13:19:08
pelagia 8  | 13:15:22
pelagia 9  | 13:16:06
pelagia 10 | 13:15:47
pelagia 11 | 13:27:14
pelagia 12 | 13:21:35
pelagia 13 | 13:24:51
pelagia 14 | 13:26:08
pelagia 15 | 13:15:59

## SortaDate

### Individual loci, fully resolved gene trees

Step 1: Convert the alignment files from Nexus to FASTA (Geneious -> Batch export).

Step 2: Generate a script to perform a RAxML analysis with SH-like support values on each of the 615 loci:

```{r, eval = FALSE}
ucelist <- read.table("/Users/David/Grive/Alfaro_Lab/Pelagia/95_percent_complete/ucelist.txt")
n <- length(unlist(ucelist))

# 1st part of the command: what to analyze

raxmlcommands <- vector(mode="character", length = n)
for(i in ucelist) {
  raxmlcommands[i] <- paste("ete3 build -w standard_raxml -n /Users/David/Grive/Alfaro_Lab/Pelagia/95_percent_complete/", i, sep = "")
}

# 2nd part of the command: names to give to the output files

withendings <- as.character(as.vector(as.matrix(ucelist)))
noendings <- vector()
for(i in withendings) {
  noendings <- append(noendings, sapply(strsplit(i, split='.', fixed=TRUE), function(x) (x[1])))
}
outputnames <- vector()
for(i in noendings) {
  outputnames <- append(outputnames, paste(" -o /Users/David/Grive/Alfaro_Lab/Pelagia/95_percent_complete/", i, sep=""))
}

length(outputnames)

# Put it together and print it to file:

commandlist <- paste(raxmlcommands, outputnames, "-tree &&", sep = "")
write(commandlist, "/Users/David/Grive/Alfaro_Lab/Pelagia/95_percent_complete/615-gene-tree-analysis.sh")
```

Step 3: Run the script as follows:

```
export PATH=~/anaconda_ete/bin:$PATH
chmod 755 /Users/David/Grive/Alfaro_Lab/Pelagia/95_percent_complete/615-gene-tree-analysis.sh
/Users/David/Grive/Alfaro_Lab/Pelagia/95_percent_complete/615-gene-tree-analysis.sh
```

Step 4: Move the resulting tree files from their nested subdirectories to the main directory:

```
find . -name '*.nw' -exec mv {} . \;
ls -lR ./*.nw | wc -l                     # Make sure you got all 615
```

Step 5: Rename the trees to give them the `.tre` file ending that SortaDate will be looking for:

```
find . -name "*.fasta.final_tree.nw" -exec rename 's/.fasta.final_tree.nw$/.tre/' {} \;
```

Step 6: get_var_length

```
python /Users/David/Grive/Alfaro_Lab/SortaDate/src/get_var_length.py /Users/David/Grive/Alfaro_Lab/Pelagia/95_percent_complete --flend .tre --outf /Users/David/Grive/Alfaro_Lab/Pelagia/var-pelagia-loci --outg ceratoscopelus_warmingii,gadus_morhua
```

Two different outgroups were selected to increase the probability that at least one of them would be present in each alignment. Note that the script seems to be sensitive to the order in which the outgroups are passed to it: `--outg gadus_morhua,ceratoscopelus_warmingii` makes the program freeze and yields an empty output file, while `--outg ceratoscopelus_warmingii,gadus_morhua` works as intended, with values successfully estimated for all 615 loci (even those in which one of the outgroups was not present).

Step 7: get_bp_genetrees

```
python /Users/David/Grive/Alfaro_Lab/SortaDate/src/get_bp_genetrees.py /Users/David/Grive/Alfaro_Lab/Pelagia/95_percent_complete /Users/David/Grive/Alfaro_Lab/Pelagia/ExaML_pelagia-75p.tre --flend .tre --outf /Users/David/Grive/Alfaro_Lab/Pelagia/bp-pelagia-loci
```

Here, too, the congruence with the reference tree was successfully estimated for all 615 gene trees.

Step 8: combine_results

```
python /Users/David/Grive/Alfaro_Lab/SortaDate/src/combine_results.py /Users/David/Grive/Alfaro_Lab/Pelagia/var-pelagia-loci /Users/David/Grive/Alfaro_Lab/Pelagia/bp-pelagia-loci --outf /Users/David/Grive/Alfaro_Lab/Pelagia/comb-pelagia-loci
```

Step 9: rate distribution:

```{r}
sortadate_results <- read.table("/Users/David/Grive/Alfaro_Lab/Pelagia/comb-pelagia-loci")
colnames(sortadate_results) <- c("Locus", "Root-to-tip_variance", "Tree_length", "Bipartition_support")
hist(sortadate_results$Tree_length, breaks = 100, xlab = "Tree length (assumed proportional to rate)", main = "Distribution of gene tree lengths / locus rates")
```

Step 10: get Robinson-Foulds distances of the individual gene trees from the reference tree:

```
import os, uuid
from ete3 import Tree

t2 = Tree("/Users/David/Grive/Alfaro_Lab/Pelagia/ExaML_pelagia-75p.tre", format = 9)
for file in os.listdir("/Users/David/Grive/Alfaro_Lab/Pelagia/95_percent_complete/"):
    if file.endswith(".tre"):
        filename = "/Users/David/Grive/Alfaro_Lab/Pelagia/95_percent_complete/" + file
        t1 = Tree(filename, format = 2)
        try:
            rf = t1.robinson_foulds(t2)
            print str(file), (rf[0])
        except:
            pass
```

```
python robinsonfoulds.py > /Users/David/Grive/Alfaro_Lab/Pelagia/rf-pelagia-loci
```

```{r, echo = FALSE}
rf <- read.table("/Users/David/Grive/Alfaro_Lab/Pelagia/rf-pelagia-loci")
colnames(rf) <- c("Locus", "Robinson_Foulds_distance")
hist(rf$Robinson_Foulds_distance, breaks = 100, xlab = "Robinson-Foulds distance from the ExaML concatenated tree", main = "Distribution of RF distances")
```

```{r, echo = FALSE, eval = FALSE}
png("/Users/David/Grive/Alfaro_Lab/Pelagia/fully_resolved_rates_and_distances.png", width = 2800, height = 1600, pointsize = 48)
par(mfrow=c(1,2), oma = c(0, 0, 2, 0))
hist(sortadate_results$Tree_length, breaks = 50, xlab = "Tree length (assumed proportional to rate)", main = "Distribution of gene tree lengths / locus rates", col = "greenyellow")
hist(rf$Robinson_Foulds_distance, breaks = 50, xlab = "RF distance from the ExaML concatenated tree", main = "Distribution of RF distances", col = "lightcoral")
mtext("615 fully resolved gene trees", outer = TRUE, cex = 1.5)
```

### Individual loci, collapsed gene trees

Step 1: Use the following Python script to collapse all nodes with SH-like support values below 0.90:

```
import os, uuid
from ete3 import Tree

for file in os.listdir("/Users/David/Grive/Alfaro_Lab/Pelagia/95_percent_complete"):
    if file.endswith(".tre"):
        filename = "/Users/David/Grive/Alfaro_Lab/Pelagia/95_percent_complete/" + file
        outname = "/Users/David/Grive/Alfaro_Lab/Pelagia/Min_SH-like_90_trees/" + file
        t = Tree(filename, format=2)

        print t.get_ascii(attributes=['support', 'name'])

        for node in t.get_descendants():
            if not node.is_leaf() and node.support <= 0.9:
                node.delete()

        print t.get_ascii(attributes=['support', 'name'])

        t.write(format=0, outfile=outname)
```

Step 2: Copy the locus alignments into the new folder:

```
cp 95_percent_complete/*.fasta Min_SH-like_90_trees
```

Step 3: Re-run SortaDate on the collapsed trees:

```
python /Users/David/Grive/Alfaro_Lab/SortaDate/src/get_var_length.py /Users/David/Grive/Alfaro_Lab/Pelagia/Min_SH-like_90_trees --flend .tre --outf /Users/David/Grive/Alfaro_Lab/Pelagia/var-pelagia-collapsed-loci --outg ceratoscopelus_warmingii,gadus_morhua
```

Note: a new type of warning was printed to the screen when the script was run, presumably due to the presence of polytomies in the collapsed trees: "this really only works with nexus or newick". Consequently, the resulting file had to be cleaned up by deleting rows that contained no information at all (i.e., neither root-to-tip variance nor tree length) and those that contained NAs:


```{r}
var_collapsed <- read.table("/Users/David/Grive/Alfaro_Lab/Pelagia/var-pelagia-collapsed-loci",na.strings=c("", "NA"), sep = "\t")
var_collapsed <- na.omit(var_collapsed)
```
```{r, eval = FALSE}
write.table(var_collapsed, "/Users/David/Grive/Alfaro_Lab/Pelagia/var-pelagia-collapsed-loci", quote = F, col.names = F, row.names = F, sep = "\t")
```

This reduced the number of usable loci from 615 to 313 (success rate = 50.9%).

```
python /Users/David/Grive/Alfaro_Lab/SortaDate/src/get_bp_genetrees.py /Users/David/Grive/Alfaro_Lab/Pelagia/Min_SH-like_90_trees /Users/David/Grive/Alfaro_Lab/Pelagia/ExaML_pelagia-75p.tre --flend .tre --outf /Users/David/Grive/Alfaro_Lab/Pelagia/bp-pelagia-collapsed-loci
```

The bipartition support scores were calculated successfully for all loci. Therefore, the next step (combining the two files) was performed manually in R rather than using the provided script:

```{r}
colnames(var_collapsed) <- c("Locus", "Variance", "Length")
bp_collapsed <- read.table("/Users/David/Grive/Alfaro_Lab/Pelagia/bp-pelagia-collapsed-loci")
colnames(bp_collapsed) <- c("Locus", "Support")
comb_collapsed <- merge(var_collapsed, bp_collapsed, by = "Locus")
```
```{r, eval = FALSE}
write.table(comb_collapsed, "/Users/David/Grive/Alfaro_Lab/Pelagia/comb-pelagia-collapsed-loci", quote = F, col.names = F, row.names = F, sep = "\t")
```

Step 4: Re-calculate the Robinson-Foulds distances from the ExaML tree:

```
python robinsonfoulds.py > /Users/David/Grive/Alfaro_Lab/Pelagia/rf-pelagia-collapsed-loci
```

Note that this step was successfully performed for 487 loci only. Moreover, not all of these overlap with the 313 loci for which root-to-tip variance and tree length are available.

Step 5: Use only the overlapping loci to construct the rate and RF-distance distributions:

```{r}
rf_collapsed <- read.table("/Users/David/Grive/Alfaro_Lab/Pelagia/rf-pelagia-collapsed-loci")
hist(var_collapsed[var_collapsed$Locus %in% rf_collapsed[,1], ]$Length, breaks = 100, xlab = "Tree length (assumed proportional to rate)", main = "Distribution of gene tree lengths / locus rates")
hist(rf_collapsed[rf_collapsed[,1] %in% var_collapsed$Locus, 2], breaks = 100, xlab = "Robinson-Foulds distance from the ExaML concatenated tree", main = "Distribution of RF distances")
```

```{r, echo = FALSE, eval = FALSE}
png("/Users/David/Grive/Alfaro_Lab/Pelagia/collapsed_rates_and_distances.png", width = 2800, height = 1600, pointsize = 48)
par(mfrow=c(1,2), oma = c(0, 0, 2, 0))
hist(var_collapsed[var_collapsed$Locus %in% rf_collapsed[,1], ]$Length, breaks = 50, xlab = "Tree length (assumed proportional to rate)", main = "Distribution of gene tree lengths / locus rates", col = "greenyellow")
hist(rf_collapsed[rf_collapsed[,1] %in% var_collapsed$Locus, 2], breaks = 100, xlab = "RF distance from the ExaML concatenated tree", main = "Distribution of RF distances", col = "lightcoral")
mtext("306 collapsed gene trees (no nodes w/ SH-like < 0.9)", outer = TRUE, cex = 1.5)
```

Step 6: exclude the 20% of loci with the shortest tree length from the 615-UCE pool as well as all of the loci in the top 20% of RF distance from the concatenated tree:

```{r}
tree_quantile <- quantile(sortadate_results$Tree_length, probs = seq(0, 1, .2))
RF_quantile <- quantile(rf$Robinson_Foulds_distance, probs = seq(0, 1, .2))
# Merge the comb and RF files:
comb_collapsed <- merge(sortadate_results, rf, by = "Locus")
filtered_loci <- comb_collapsed[comb_collapsed$Tree_length > tree_quantile[2] & comb_collapsed$Robinson_Foulds_distance < RF_quantile[5],]
```
```{r, eval = FALSE}
write.table(filtered_loci, "/Users/David/Grive/Alfaro_Lab/Pelagia/filtered_loci.txt", row.names = FALSE, col.names = FALSE, quote = FALSE, sep = "\t")
```

These selection criteria yielded a filtered dataset of 440 loci (71.5% of the original number), suggesting that the nearly invariant loci with the shortest tree length also performed the worst in terms of topology estimation.

Step 7: create a directory with just the selected loci:

Step 7.1: get a list of the names of the corresponding tree files:

```{r, eval = FALSE}
write.table(filtered_loci$Locus, "/Users/David/Grive/Alfaro_Lab/Pelagia/95_percent_complete/filtered_loci_names.txt", row.names = FALSE, col.names = FALSE, quote = FALSE)
```

Step 7.2: change the endings so that the file lists alignments rather than trees:

```
gsed -i 's/tre/fasta/g' filtered_loci_names.txt
```

Step 7.3: copy the files listed to a new directory:

```
for file in `cat filtered_loci_names.txt`; do cp "$file" /Users/David/Grive/Alfaro_Lab/Pelagia/Filtered/ ; done
```

#### Track 1: PartitionFinder on sites

Step 1: change the alignment ending to make the files recognizable to FASconCAT:

```
find . -name "*.fasta" -exec rename 's/.fasta$/.fas/' {} \;
```

Step 2: concatenate the 440 loci using FASconCAT (make sure the Perl script is in the same directory as the FASTA files!):

```
perl FASconCAT_v1.1.pl -s
```

Step 3: convert the concatenated alignment from FASTA to PhyML to make it readable by PartitionFinder:

```
perl catfasta2phyml-master/catfasta2phyml.pl --verbose Pelagia/Filtered/FcC_smatrix.fas > pelagia-filtered-concat.phy
```

Step 4: run PartitionFinder on the following configuration file using the command below:

```{r comment='', echo = FALSE}
cat(readLines("/Users/David/Grive/Alfaro_Lab/Pelagia/PartitionFinder/partition_finder.cfg"), sep = '\n')
```

```
python PartitionFinder.py /home/analysis/partitionfinder-new/pelagia-filtered-loci/partition_finder.cfg --verbose --raxml --save-phylofiles
```

Step 5: extract the list of partitions from `best_scheme.txt` and read it into R:

```{r}
partitions <- read.table("/Users/David/Grive/Alfaro_Lab/Pelagia/PartitionFinder/partitions.txt", sep = "|", header = TRUE)
```

Step 6: prepare a list of alignments and information files to download:

```{r}
alignments <- paste(gsub(" ", "", partitions[,4], fixed = TRUE), ".phy", sep = "")
infofiles <- paste("RAxML_info.", gsub(" ", "", partitions[,4], fixed = TRUE), "_GTR+G.txt", sep = "")
```
```{r, eval = FALSE}
write(cbind(alignments, infofiles), "/Users/David/Grive/Alfaro_Lab/Pelagia/PartitionFinder/whattorsync.txt")
```

Step 7: download the relevant files as follows:

```
rsync --files-from=/Users/David/Grive/Alfaro_Lab/Pelagia/PartitionFinder/Partitions/whattorsync.txt analysis@azathoth.eeb.ucla.edu:~/partitionfinder-new/pelagia-filtered-loci/analysis/phylofiles /Users/David/Grive/Alfaro_Lab/Pelagia/PartitionFinder/Partitions
```

State 8: extract the branch length multipliers from all the info files:

```
for file in `cat whattorsync.txt`; do gsed -n -e 's/^.*Branch length scaler: //p' "$file"; done > multipliers.txt
```

State 9: add the rate info to your initial partition table:

```{r}
multipliers <- read.table("/Users/David/Grive/Alfaro_Lab/Pelagia/PartitionFinder/Partitions/multipliers.txt")
partitions <- cbind(partitions, multipliers)
```

Step 10: plot partition rate against partition length:

```{r}
plot(partitions[,3], partitions[,6], xlab = "Partition length (bp)", ylab = "Relative rate", pch = 19, main = "All 37 partitions")
plot(partitions[,3], partitions[,6], xlim = c(0, 20000), xlab = "Partition length (bp)", ylab = "Relative rate", pch = 19, main = "(Longest partition excluded)")
```

#### Track 3: SortaDate on the filtered loci

Step 1: Subset the `comb-pelagia-loci` so that it contains only the 440 selected loci:

```{r, eval = FALSE}
comb_filtered <- sortadate_results[sortadate_results$Locus %in% filtered_loci$Locus,]
write.table(comb_filtered, "/Users/David/Grive/Alfaro_Lab/Pelagia/comb-pelagia-filtered-loci", row.names = FALSE, col.names = FALSE, quote = FALSE, sep = "\t")
```

Step 2: run the `get_good_genes` with default weights assigned to the three available criteria (i.e., in order of descending priority: bipartition support, root-to-tip variance, tree length) to sort the 440 loci from best to worst:

```
python /Users/David/Grive/Alfaro_Lab/SortaDate/src/get_good_genes.py /Users/David/Grive/Alfaro_Lab/Pelagia/comb-pelagia-filtered-loci --max 440 --order 3,1,2 --outf /Users/David/Grive/Alfaro_Lab/Pelagia/gg-pelagia-filtered
```

Step 3: make bivariate plots showing the relationships between each pair of variables:

```{r, echo = FALSE}
gg_pelagia <- read.table("/Users/David/Grive/Alfaro_Lab/Pelagia/gg-pelagia-filtered", header = TRUE)
plot(gg_pelagia$bipartition, gg_pelagia$treelength, xlab = "Bipartition support", ylab = "Tree length", main = "Filtered dataset: tree length vs. bipartition support")
abline(lm(gg_pelagia$treelength ~ gg_pelagia$bipartition))
plot(gg_pelagia$bipartition, gg_pelagia$root.to.tip_var, xlab = "Bipartition support", ylab = "Root-to-tip variance", main = "Filtered dataset: clockiness vs. bipartition support")
abline(lm(gg_pelagia$root.to.tip_var ~ gg_pelagia$bipartition))
plot(gg_pelagia$root.to.tip_var, gg_pelagia$treelength, xlab = "Root-to-tip variance", ylab = "Tree length", main = "Filtered dataset: tree length vs. clockiness")
abline(lm(gg_pelagia$treelength ~ gg_pelagia$root.to.tip_var))
```